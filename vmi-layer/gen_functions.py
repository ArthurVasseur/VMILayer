import json
import xml.etree.ElementTree as ET
from evaluate_dependency import evaluate_dependency
registry = ET.parse('./vk.xml').getroot()

platform_defines = {}
for platform in registry.findall('platforms/platform'):
    platform_defines[platform.attrib['name']] = platform.attrib['protect']

commands = {}

for cmd in registry.findall('commands/command'):
    if 'alias' in cmd.attrib:
        continue

    name = cmd.find('proto/name').text.strip()
    if name in commands:
        continue

    return_value = cmd.find('proto/type').text.strip()

    params = []
    param_names = []
    for param in cmd.findall('param'):
        parts = []
        if param.text:
            parts.append(param.text.strip())
        for child in param:
            parts.append(child.text.strip())
            if child.tail:
                parts.append(child.tail.strip())
        param_str = ' '.join(parts).replace('  ', ' ').strip()
        param_names.append(param_str.split(' ')[-1])
        params.append(param_str)

    prototype = f"{return_value} {name}("
    if params:
        prototype += " "
        for i, p in enumerate(params):
            comma = ',' if i < len(params) - 1 else ''
            prototype += f"{p}{comma} "
    prototype += ")"

    commands[name] = {
       'prototype': prototype,
       'name': name,
       'return_value': return_value if return_value != 'void' else None,
       'param_names': param_names,
    }

features = {}
processed_commands = []

for feature in registry.findall('feature'):
    if 'api' not in feature.attrib:
        continue
    api_version_define = None
    for require in feature.findall('require'):
        if api_version_define is None:
            for type_elem in require.findall('type'):
                if 'API_VERSION' in type_elem.attrib['name']:
                    api_version_define = feature.attrib['name']
                    break

        for command in require.findall('command'):
            name = command.attrib['name']
            if name in commands or name in processed_commands:
                continue
            processed_commands.append(name)
            print(f"Command {name} not found in commands")
            features[api_version_define] = features.get(api_version_define, []) + [commands[name]]

extensions = {}

for extension in registry.findall('extensions/extension'):
    if 'disabled' in extension.attrib['supported']:
        continue
    ext_name = extension.attrib['name']
    depends = evaluate_dependency(extension.attrib['depends']) if 'depends' in extension.attrib else None
    platform = extension.attrib['platform'] if 'platform' in extension.attrib else None
    cmds = []
    for require in extension.findall('require'):
        for command in require.findall('command'):
            name = command.attrib['name']
            if name in processed_commands or name not in commands:
                continue
            processed_commands.append(name)
            cmds.append(commands[name])
    extensions[ext_name] = {
        'depends': [] if depends is None else depends,
        'platform': None if platform is None else platform_defines[platform],
        'commands': cmds,
    }

def generate_code(defines: list[str], cmds: list[dict]) -> None:
    defines_str = ' && '.join([f'{d}' for d in defines if d])
    if defines:
        f.write(f'#if {defines_str}\n')
    for cmd in cmds:
        f.write(f"{cmd['prototype']}\n{{\n")
        f.write(
            f"""    const auto* dp = VulkanMemoryInspector::GetInstance()->GetDeviceDispatchTable(GetKey({cmd['param_names'][0]}));
    if (!dp)
    {{
        CCT_ASSERT_FALSE("Could not get the device dispatch table");
        return {"VK_ERROR_INVALID_EXTERNAL_HANDLE" if cmd['return_value'] else ''};
    }}
    VulkanEvent vmiEvent = {{}};
    auto buff = Serialize(vmiEvent);
    VulkanMemoryInspector::GetInstance()->Send(buff);
    return dp->{cmd['name'][2:]}({', '.join(cmd['param_names'])});
"""
        )
        f.write("}\n\n")
    if defines:
        f.write(f"#endif // {defines_str}\n\n")


with open('commands.cpp', 'w') as f:
    f.write('// This file is generated by gen_vulkan.py\n')
    f.write('#include <vulkan/vulkan.h>\n')
    f.write('#include "VMI/Defines.hpp"\n')
    f.write('#include "VMI/VulkanMemoryInspector.hpp"\n')
    f.write('#include "VMI/Bindings.hpp"\n\n')
    for feature, cmds in features.items():
        generate_code([feature], cmds)
    for ext, data in extensions.items():
        defines_list =     ([data['depends']] if isinstance(data['depends'], str) else data['depends']) + ([data['platform']] if data['platform'] else [])
        generate_code(defines_list, data['commands'])
